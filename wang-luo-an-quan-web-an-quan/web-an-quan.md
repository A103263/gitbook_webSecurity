---
description: 什么是反序列化漏洞
---

# 反序列化漏洞

## 序列化和反序列化

#### 序列化（Serialization）：就是将对象的状态信息转换为可以存储或传输的形式的过程。

什么时候才会用到序列化，或者说为什么要用序列化？

我们的都知道，文本，图片音乐等等，都可以在网络上进行二进制的传输，有没有想过如果传输一个对象应该如何传输，或者说当计算机创建出来的对象已经超过内存的大小，需要将暂时不用的对象存储在外存储器上，计算机该如何存储呢？程序中的类多而复杂，怎样保证你传过去的对象，对方的计算机可以识别？这时候序列化就出来了。序列化后的对象采用了一种公共的格式来保证不同的计算机能够识别。下面以php序列化对象后的数据格式来理解一下序列化后的对象。

我们定义一个学生类，并实例化一个学生对象，将这个学生对象序列化后输出

```php
class Student{
    private $ID;
    private $name;
    private $age;

    function __construct($id,$name,$age)
    {
        $this->ID = $id;
        $this->name = $name;
        $this->age = $age;
    }

    function S_print(){
        echo "学号:".$this->ID."姓名:".$this->name."年龄:".$this->age."<br>";
    }
}

$s1 = new Student(100,'chen',17);
echo serialize($s1);
```

输出一下

```text
O:7:"Student":3:{s:11:"StudentID";i:100;s:13:"Studentname";s:4:"chen";s:12:"Studentage";i:17;}
//大括号外边：O代表这是个对象，7代表类名的长度，Student是类名，3代表的是有三个属性
//括号内：s字符串，11字符串长度，StudentID类名加属性名 i代表数字型，100是值，后面的也都差不多
```

试着将其反序列化

```php
$str = serialize($s1);
echo $str.'<br>';
$s2 = unserialize($str);
$s2->S_print();
```

![](../.gitbook/assets/image%20%2819%29.png)

**总结一下，为什么需要序列化和反序列化**

* 传输：服务端把数据序列化，发送到客户端，客户端吧接受到的数据反序列化后对数据进行操作，完成后再序列化发送到服务端，服务端再反序列化数据后对数据进行操作。
* 存储：将内存中的对象状态保存至文件或者数据库中，供之后使用。

### 何为反序列化漏洞

        序列化与反序列化机制本身并无问题，但是应用程序对于用户输入的数据（不可信的数据）进行了反序列化处理，使得反序列化生成了非预期的对象，在对象的产生过程中可能产生攻击行为（例如任意代码执行）  
        常见的编程语言PHP、JAVA、Python中均具有反序列化机制，一些应用程序或者公共库编写或者逻辑不规范，导致出现了反序列化的问题。如JAVA的Apache Commons Collections的广泛使用，导致WebLogic、WebSphere、JBoss、Jenkins等应用均具有此漏洞。

